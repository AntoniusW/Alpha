package at.ac.tuwien.kr.alpha.grounder.transformation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import at.ac.tuwien.kr.alpha.common.ComparisonOperator;
import at.ac.tuwien.kr.alpha.common.Predicate;
import at.ac.tuwien.kr.alpha.common.atoms.AggregateAtom;
import at.ac.tuwien.kr.alpha.common.atoms.AggregateAtom.AggregateElement;
import at.ac.tuwien.kr.alpha.common.atoms.AggregateAtom.AggregateFunctionSymbol;
import at.ac.tuwien.kr.alpha.common.atoms.AggregateLiteral;
import at.ac.tuwien.kr.alpha.common.atoms.Atom;
import at.ac.tuwien.kr.alpha.common.atoms.BasicAtom;
import at.ac.tuwien.kr.alpha.common.atoms.BasicLiteral;
import at.ac.tuwien.kr.alpha.common.atoms.Literal;
import at.ac.tuwien.kr.alpha.common.program.InputProgram;
import at.ac.tuwien.kr.alpha.common.rule.BasicRule;
import at.ac.tuwien.kr.alpha.common.rule.head.NormalHead;
import at.ac.tuwien.kr.alpha.common.terms.ConstantTerm;
import at.ac.tuwien.kr.alpha.common.terms.FunctionTerm;
import at.ac.tuwien.kr.alpha.common.terms.Term;
import at.ac.tuwien.kr.alpha.common.terms.Terms;
import at.ac.tuwien.kr.alpha.common.terms.VariableTerm;
import at.ac.tuwien.kr.alpha.grounder.parser.InlineDirectives;
import at.ac.tuwien.kr.alpha.grounder.parser.InlineDirectives.DIRECTIVE;
import at.ac.tuwien.kr.alpha.grounder.parser.ProgramParser;

/**
 * Performs rewriting steps for aggregate literals that "bind" variables, i.e. variables get their values from the exact
 * value of the aggregate.
 * 
 * Specifically, this transformation handles literals of formats "X = #count{...}", "X = #sum{...}", as well as "X OP
 * #min{...}" and "X OP #max{...}" for any operator OP.
 * 
 * For "#count" and "#sum" aggregates, the code generated by this transformation works as a "wrapper" for the rewriting
 * performed by {@link at.ac.tuwien.kr.alpha.grounder.transformation.CardinalityNormalization} and
 * {@link at.ac.tuwien.kr.alpha.grounder.transformation.SumNormalization}.
 * Both "#count" and "#sum" aggregates with an equality operator are rewritten into constructs using only "VAR <=
 * #count{...}" and "VAR <= #sum{...}", respectively.</br>
 * </br>
 * <b>Examples</b></br>
 * The program
 * 
 * <pre>
 * 	thing(1..3).
 *  cnt_things(N) :- N = #count{X : thing(X)}.
 * </pre>
 * 
 * is rewritten to:
 * 
 * <pre>
 *  thing(1..3).
 *  aggregate(count_1).
 *  cnt_things(N) :- aggregate_result(count_1, N).
 *  aggregate_result(AGGREGATE_ID, VAL) :- 
 *      aggregate(AGGREGATE_ID),
 *      leq_aggregate(AGGREGATE_ID, VAL), 
 *      not leq_aggregate(AGGREGATE_ID, NEXTVAL), 
 *      NEXTVAL = VAL + 1.
 *  cnt_element_tuple(count_1, tuple(X)) :- thing(X).
 *  cnt_candidate(AGGREGATE_ID, I) :- 
 *      aggregate(AGGREGATE_ID), 
 *      cnt_element_tuple(AGGREGATE_ID, TUPLE), 
 *      _Enumeration(AGGREGATE_ID, TUPLE, I).
 *  leq_aggregate(count_1, CNT) :- CNT <= #count{ X : thing(X) }, cnt_candidate(count_1, CNT).
 * </pre>
 * 
 * The gist of the rewriting is that "N = #count{X : thing(X)}" is equivalent to
 * "N <= #count{X : thing(X)}, not N + 1 <= #count{X : thing(X)}". Since in this "naively" rewritten version, the
 * variable N is not bound, the tuples over which the aggregate counts are enumerated using the internal "_Enumeration"
 * atom, such that every value in the interval 0..N is a "cnt_candidate".</br>
 * 
 * Similarly, the program
 * 
 * <pre>
 *  item_cost(bread, 1).
 *  item_cost(salad, 2).
 *  item_cost(cookies, 2).
 *  item_cost(beer, 3).
 *  item_cost(wine, 7).
 *  total_cost(VAL) :- VAL = #sum{S, N : item_cost(N, S)}.
 * </pre>
 * 
 * is rewritten to:
 * 
 * <pre>
 *  item_cost(bread, 1).
 *  item_cost(salad, 2).
 *  item_cost(cookies, 2).
 *  item_cost(beer, 3).
 *  item_cost(wine, 7).
 *  
 *  aggregate(sum_1).
 *  total_cost(VAL) :- aggregate_result(sum_1, VAL).
 *  aggregate_result(AGGREGATE_ID, VAL) :- 
 *      aggregate(AGGREGATE_ID),
 *      leq_aggregate(AGGREGATE_ID, VAL), 
 *      not leq_aggregate(AGGREGATE_ID, NEXTVAL),
 *      NEXTVAL = VAL + 1.
 *  leq_aggregate(sum_1, SUM) :- SUM <= #sum{ S, N : item_cost(N, S) }, sum_candidate(sum_1, SUM).
 *  sum_element_tuple(sum_1, tuple(S, N), S) :- item_cost(N, S).
 *  sum_element_at_index(SUM_ID, VAL, IDX) :- 
 *      aggregate(SUM_ID), sum_element_tuple(SUM_ID, TPL, VAL), 
 *      element_tuple_ordinal(SUM_ID, TPL, IDX).
 *  sum_element_index(SUM_ID, IDX) :- sum_element_at_index(SUM_ID, _0, IDX).
 *  sum_at_idx_candidate(SUM_ID, 0, 0) :- sum_element_at_index(SUM_ID, _1, _2).
 *  sum_at_idx_candidate(SUM_ID, I, CSUM) :- 
 *      sum_element_index(SUM_ID, I), 
 *      sum_at_idx_candidate(SUM_ID, IPREV, CSUM), 
 *      IPREV = I - 1.
 *  sum_at_idx_candidate(SUM_ID, I, CSUM) :- 
 *      sum_element_at_index(SUM_ID, VAL, I), 
 *      sum_at_idx_candidate(SUM_ID, IPREV, PSUM), 
 *      IPREV = I - 1, 
 *      CSUM = PSUM + VAL.
 *  sum_candidate(SUM_ID, CSUM) :- sum_at_idx_candidate(SUM_ID, _3, CSUM).
 * </pre>
 * 
 * The basic idea behind this is the same as for the "#count" scenario. However, since in this case, any intermediate
 * sum of elements contributing to the sum is a possible result, the code to find candidate values is a bit more
 * involved.
 * 
 * Copyright (c) 2020, the Alpha Team.
 */
public class BindingAggregateTransformation extends AbstractAggregateTransformation {

	private static final Predicate AGGREGATE = Predicate.getInstance("aggregate", 1);
	private static final Predicate LEQ_AGGREGATE = Predicate.getInstance("leq_aggregate", 2);

	private static final Predicate CNT_CANDIDATE = Predicate.getInstance("cnt_candidate", 2);
	private static final Predicate SUM_CANDIDATE = Predicate.getInstance("sum_candidate", 2);
	private static final Predicate CNT_ELEMENT_TUPLE = Predicate.getInstance("cnt_element_tuple", 2);
	private static final Predicate SUM_ELEMENT_TUPLE = Predicate.getInstance("sum_element_tuple", 3);
	private static final Predicate MINMAX_ELEMENT_TUPLE = Predicate.getInstance("minmax_element_tuple", 2);
	private static final Predicate ELEMENT_TUPLE_ORDINAL = Predicate.getInstance("element_tuple_ordinal", 3);

	private static final String ELEMENT_TUPLE_FN_SYM = "tuple";

	private static final String CNT_CANDIDATE_RULE = String.format(
			"%s(AGGREGATE_ID, I) :- %s(AGGREGATE_ID), %s(AGGREGATE_ID, TUPLE), %s(AGGREGATE_ID, TUPLE, I).",
			CNT_CANDIDATE.getName(), AGGREGATE.getName(), CNT_ELEMENT_TUPLE.getName(), ELEMENT_TUPLE_ORDINAL.getName());

	//@formatter:off
	// TODO can we get around hardcoded predicate names here??
	private static final String SUM_CANDIDATE_PROG = 
			"sum_element_at_index(SUM_ID, VAL, IDX) :- aggregate(SUM_ID), sum_element_tuple(SUM_ID, TPL, VAL), element_tuple_ordinal(SUM_ID, TPL, IDX)."
			+ "sum_element_index(SUM_ID, IDX) :- sum_element_at_index(SUM_ID, _, IDX)."
			// In case all elements are false, 0 is a candidate sum
			+ "sum_at_idx_candidate(SUM_ID, 0, 0) :- sum_element_at_index(SUM_ID, _, _)."
			// Assuming the element with index I is false, all candidate sums up to the last index are also valid candidates for
			// this index
			+ "sum_at_idx_candidate(SUM_ID, I, CSUM) :- sum_element_index(SUM_ID, I), sum_at_idx_candidate(SUM_ID, IPREV, CSUM), IPREV = I - 1."
			// Assuming the element with index I is true, all candidate sums up to the last index plus the value of the element at
			// index I are candidate sums."
			+ "sum_at_idx_candidate(SUM_ID, I, CSUM) :- sum_element_at_index(SUM_ID, VAL, I), sum_at_idx_candidate(SUM_ID, IPREV, PSUM), IPREV = I - 1, CSUM = PSUM + VAL."
			// Project indices away, we only need candidate values for variable binding.
			+ "sum_candidate(SUM_ID, CSUM) :- sum_at_idx_candidate(SUM_ID, _, CSUM).";
	
	private static final String MIN_ELEMENT_SEARCH_PROG =
			"element_tuple_less_than(AGGREGATE_ID, LESS, THAN) :- "
			+ "aggregate(AGGREGATE_ID), minmax_element_tuple(AGGREGATE_ID, LESS), minmax_element_tuple(AGGREGATE_ID, THAN), LESS < THAN."
			+ "element_tuple_has_smaller(AGGREGATE_ID, TPL) :- element_tuple_less_than(AGGREGATE_ID, _, TPL)."
			+ "min_element_tuple(AGGREGATE_ID, MIN) :- "
			+ "aggregate(AGGREGATE_ID), minmax_element_tuple(AGGREGATE_ID, MIN), not element_tuple_has_smaller(AGGREGATE_ID, MIN).";
	//@formatter:on

	private final ProgramParser parser = new ProgramParser();

	@Override
	protected boolean shouldHandle(AggregateLiteral lit) {
		AggregateAtom atom = lit.getAtom();
		if (atom.getAggregatefunction() == AggregateFunctionSymbol.MIN || atom.getAggregatefunction() == AggregateFunctionSymbol.MAX) {
			return true;
		} else {
			return atom.getLowerBoundOperator() == ComparisonOperator.EQ;
		}
	}

	@Override
	protected InputProgram encodeAggregates(AggregateRewritingContext ctx) {
		// create aggregate facts
		List<Atom> aggregateFacts = new ArrayList<>();
		Map<AggregateFunctionSymbol, List<AggregateLiteral>> aggregateFunctionsToEncode = new HashMap<>();
		for (AggregateLiteral lit : ctx.getLiteralsToRewrite()) {
			aggregateFacts.add(new BasicAtom(AGGREGATE, ConstantTerm.getSymbolicInstance(ctx.getAggregateId(lit))));
			aggregateFunctionsToEncode.putIfAbsent(lit.getAtom().getAggregatefunction(), new ArrayList<>());
			aggregateFunctionsToEncode.get(lit.getAtom().getAggregatefunction()).add(lit);
		}
		List<BasicRule> aggregateEncodingRules = new ArrayList<>();
		for (AggregateFunctionSymbol func : aggregateFunctionsToEncode.keySet()) {
			aggregateEncodingRules.addAll(encodeAggregateFunction(func, aggregateFunctionsToEncode.get(func), ctx));
		}
		InlineDirectives directives = new InlineDirectives();
		directives.addDirective(DIRECTIVE.enum_predicate_is, ELEMENT_TUPLE_ORDINAL.getName());
		InputProgram aggregateEncoding = new InputProgram(aggregateEncodingRules, aggregateFacts, directives);
		return aggregateEncoding;
	}

	private BasicRule buildEqualityRule() {
		VariableTerm aggregateIdVar = VariableTerm.getInstance("AGGREGATE_ID");
		VariableTerm valueVar = VariableTerm.getInstance("VAL");
		VariableTerm nextValVar = VariableTerm.getInstance("NEXTVAL");
		Atom headAtom = new BasicAtom(AbstractAggregateTransformation.AGGREGATE_RESULT, aggregateIdVar, valueVar);
		Literal leqValue = new BasicLiteral(new BasicAtom(LEQ_AGGREGATE, aggregateIdVar, valueVar), true);
		Literal notLeqNextval = new BasicLiteral(new BasicAtom(LEQ_AGGREGATE, aggregateIdVar, nextValVar), false);
		Literal bindNextval = Terms.incrementTerm(valueVar, nextValVar);
		Literal bindAggregateId = new BasicLiteral(new BasicAtom(AGGREGATE, aggregateIdVar), true);
		return BasicRule.getInstance(new NormalHead(headAtom), leqValue, notLeqNextval, bindNextval, bindAggregateId);
	}

	private BasicRule buildCountElementTupleRule(String aggregateId, AggregateElement element) {
		FunctionTerm elementTuple = FunctionTerm.getInstance(ELEMENT_TUPLE_FN_SYM, element.getElementTerms());
		Atom headAtom = new BasicAtom(CNT_ELEMENT_TUPLE, ConstantTerm.getSymbolicInstance(aggregateId), elementTuple);
		return new BasicRule(new NormalHead(headAtom), element.getElementLiterals());
	}

	private BasicRule buildSumElementTupleRule(String aggregateId, AggregateElement element) {
		FunctionTerm elementTuple = FunctionTerm.getInstance(ELEMENT_TUPLE_FN_SYM, element.getElementTerms());
		Term sumTerm = element.getElementTerms().get(0);
		Atom headAtom = new BasicAtom(SUM_ELEMENT_TUPLE, ConstantTerm.getSymbolicInstance(aggregateId), elementTuple, sumTerm);
		return new BasicRule(new NormalHead(headAtom), element.getElementLiterals());
	}

	private BasicRule buildOrderedElementTupleRule(String aggregateId, AggregateElement element) {
		FunctionTerm elementTuple = FunctionTerm.getInstance(ELEMENT_TUPLE_FN_SYM, element.getElementTerms());
		Atom headAtom = new BasicAtom(MINMAX_ELEMENT_TUPLE, ConstantTerm.getSymbolicInstance(aggregateId), elementTuple);
		return new BasicRule(new NormalHead(headAtom), element.getElementLiterals());
	}

	private BasicRule buildCntLeqRule(AggregateLiteral countEq, String countEqId) {
		VariableTerm cnt = VariableTerm.getInstance("CNT");
		Atom headAtom = new BasicAtom(LEQ_AGGREGATE, ConstantTerm.getSymbolicInstance(countEqId), cnt);
		AggregateAtom sourceAggregate = countEq.getAtom();
		Literal valueLeqCnt = new AggregateLiteral(
				new AggregateAtom(ComparisonOperator.LE, cnt, null, null, AggregateFunctionSymbol.COUNT, sourceAggregate.getAggregateElements()), true);
		Literal valueIsCandidate = new BasicLiteral(new BasicAtom(CNT_CANDIDATE, ConstantTerm.getSymbolicInstance(countEqId), cnt), true);
		return BasicRule.getInstance(new NormalHead(headAtom), valueLeqCnt, valueIsCandidate);
	}

	private BasicRule buildSumLeqRule(AggregateLiteral sumEq, String sumEqId) {
		VariableTerm sum = VariableTerm.getInstance("SUM");
		Atom headAtom = new BasicAtom(LEQ_AGGREGATE, ConstantTerm.getSymbolicInstance(sumEqId), sum);
		AggregateAtom sourceAggregate = sumEq.getAtom();
		Literal valueLeqSum = new AggregateLiteral(
				new AggregateAtom(ComparisonOperator.LE, sum, null, null, AggregateFunctionSymbol.SUM, sourceAggregate.getAggregateElements()), true);
		Literal valueIsCandidate = new BasicLiteral(new BasicAtom(SUM_CANDIDATE, ConstantTerm.getSymbolicInstance(sumEqId), sum), true);
		return BasicRule.getInstance(new NormalHead(headAtom), valueLeqSum, valueIsCandidate);
	}

	private BasicRule buildMinAggregateResultRule(String aggregateId) {
		return parser.parse(String.format("aggregate_result(%s, M) :- min_element_tuple(%s, tuple(M)).", aggregateId, aggregateId)).getRules().get(0);
	}

	private List<BasicRule> encodeAggregateFunction(AggregateFunctionSymbol func, List<AggregateLiteral> literals, AggregateRewritingContext ctx) {
		switch (func) {
			case COUNT:
				return encodeCountAggregate(literals, ctx);
			case SUM:
				return encodeSumAggregate(literals, ctx);
			case MIN:
				return encodeMinAggregate(literals, ctx);
			case MAX:
			default:
				throw new UnsupportedOperationException();
		}
	}

	private List<BasicRule> encodeCountAggregate(List<AggregateLiteral> literals, AggregateRewritingContext ctx) {
		List<BasicRule> retVal = new ArrayList<>();
		for (AggregateLiteral countAggregate : literals) {
			for (AggregateElement element : countAggregate.getAtom().getAggregateElements()) {
				retVal.add(buildCountElementTupleRule(ctx.getAggregateId(countAggregate), element));
			}
			retVal.add(buildCntLeqRule(countAggregate, ctx.getAggregateId(countAggregate)));
		}
		InputProgram candidateRulePrg = parser.parse(CNT_CANDIDATE_RULE);
		retVal.add(candidateRulePrg.getRules().get(0));
		retVal.add(buildEqualityRule());
		return retVal;
	}

	private List<BasicRule> encodeSumAggregate(List<AggregateLiteral> literals, AggregateRewritingContext ctx) {
		List<BasicRule> retVal = new ArrayList<>();
		for (AggregateLiteral sumAggregate : literals) {
			for (AggregateElement element : sumAggregate.getAtom().getAggregateElements()) {
				retVal.add(buildSumElementTupleRule(ctx.getAggregateId(sumAggregate), element));
			}
			retVal.add(buildSumLeqRule(sumAggregate, ctx.getAggregateId(sumAggregate)));
		}
		InputProgram candidateGenerationPrg = parser.parse(SUM_CANDIDATE_PROG);
		retVal.addAll(candidateGenerationPrg.getRules());
		retVal.add(buildEqualityRule());
		return retVal;
	}

	private List<BasicRule> encodeMinAggregate(List<AggregateLiteral> literals, AggregateRewritingContext ctx) {
		List<BasicRule> retVal = new ArrayList<>();
		for (AggregateLiteral minAggregate : literals) {
			for (AggregateElement element : minAggregate.getAtom().getAggregateElements()) {
				retVal.add(buildOrderedElementTupleRule(ctx.getAggregateId(minAggregate), element));
			}
			retVal.add(buildMinAggregateResultRule(ctx.getAggregateId(minAggregate)));
		}
		InputProgram minElementSearchPrg = parser.parse(MIN_ELEMENT_SEARCH_PROG);
		retVal.addAll(minElementSearchPrg.getRules());
		return retVal;
	}

	private List<BasicRule> encodeMaxAggregate(List<AggregateLiteral> literals, AggregateRewritingContext ctx) {
		return null;
	}

}
